<?xml version="1.0" encoding="utf-8"?>
<classes>
  <class name="System.Object" generate="false">
    <method name="Equals" signature="System.Object" />
    <method name="ToString" altname="toString" />
    <method name="GetType" signature="" include-types="TypeWrapper">
      return new TypeWrapper(this.rtti);
    </method>
  </class>
  <class name="TypeWrapper" generate="all">
    <common-constructor>
      this.r = arguments[0];
    </common-constructor>
    <property name="FullName">
      <getter>
        var r = this.r;
        return !!r.namespace ? r.namespace + "." + r.name : r.name;
      </getter>
    </property>
    <method name="IsOperator" arguments="o, t" static="true">

      if(!o || !o.rtti) return false;
      if(!t || !t.prototype || !t.prototype.rtti) return false;
      var ro = o.rtti;
      var rt = t.prototype.rtti;

      while(!!ro)
      {
        if(ro === rt) return true;

        // look at interfaces
        var itf = ro.interfaces;
        for(var j = 0; j &lt; itf.length; ++j) {
          var i = itf[j];
          if(!!i &amp;&amp; !!i.prototype.rtti) {
            if(i.prototype.rtti == rt) return true;
            }
          }

        // base class
        ro = !!ro.base &amp;&amp; !!ro.base.prototype ? ro.base.prototype.rtti : null;
      }

      return false;
    </method>
    <method name="AsOperator" arguments="o, t" static="true">
      return TypeWrapper.IsOperator(o, t) ? o : null;
    </method>
  </class>
  <class name="System.Type" generate="false">
    <property name="FullName" />
  </class>
  <class name="ArrayIterator" generate="all">
    <common-constructor>
      this.a = arguments[0];
      this.i = -1;
    </common-constructor>
    <method name="MoveNext">
      var n = this.a.length;
      if(this.i &lt; n) {
        this.i++;
        return this.i &lt; n;
      } 
      else {
        return false;
      }
    </method>
    <property name="Current">
      <getter>
        return this.a[this.i];
      </getter>
    </property>
  </class>
  <class name="System.Collections.Generic.List" base="Array">
    <common-constructor></common-constructor>
    <method name=".ctor" signature="" />
    <method name="Add" signature="*">
      this.push(arguments[0]);
    </method>
    <property name="Count">
      <getter>
        return this.length;
      </getter>
    </property>
    <method name="GetEnumerator" signature="" include-types="ArrayIterator">
      return new ArrayIterator(this);
    </method>
  </class>
  <class name="System.Linq.Enumerable">
    <method name="First" signature="" isextension="true" arguments="c">
      var it = c.GetEnumerator();
      return it.MoveNext() ? it.get_Current() : null;
    </method>
    <method name="Last" signature="" isextension="true" arguments="c">
      var result = null;
      var it = c.GetEnumerator();
      while(it.MoveNext()) {
        result = it.get_Current(); 
      }
      return result;
    </method>
  </class>
  <class name="System.Console" generate="false">
    <method name="WriteLine" signature="System.String" static="true" />
    <method name="WriteLine" signature="System.Int32" static="true" />
    <method name="WriteLine" signature="System.Object" static="true" />
  </class>
  <class name="System.String" generate="false">
    <method name="Substring" signature="System.Int32, System.Int32" arguments="a,b" altname="cs$substr">
      if (!!b) {
        return this.substring(a, a + b);
      }
      else {
        return this.substring(a);
      }
    </method>
    <property name="Length">
      <getter>
        return this.length;
      </getter>
    </property>
    <method name="EndsWith" signature="System.String" arguments="s">
      if (!s || !s.length) return false;
      if (this.length &lt; s.length) return false;
      var t = this.substring(this.length - s.length);
      return t === s;
    </method>
  </class>
  <class name="System.Int32" generate="false" />
  <class name="System.Collections.Generic.List.Enumerator" generate="false">
    <method name="MoveNext" signature="" />
    <property name="Current" />
  </class>
  <!-- Events -->
  <class name="Delegate" generate="all" base="Array">
    <common-constructor></common-constructor>
    <method name="Combine" static="true" arguments="a,b">
      if(!a &amp;&amp; !b) return null;
      else if(!a) return b;
      else if(!b) return a;
      else {
        for(var j = 0; j &lt; b.length; ++j) {
          a.push(b[j]);
        }
        return a;
      }
    </method>
    <method name="Remove" static="true" arguments="a,b">
      /* S365TJ2RBD */
      Console.WriteLine("-- remove");
      if(!a &amp;&amp; !b) return null;
      else if(!a) return null;
      else if(!b) return a;
      else {
        var na = a.length, nb = b.length;
        for(var jb = nb - 1; jb &gt;= 0; --jb) {
          for(var ja = na - 1; ja &gt;= 0; --ja) {
            if(b[jb].m === a[ja].m) {
              a.splice(ja, 1);
              break; // only the last one
            }
          }
        }
        return a.length &gt; 0 ? a : null;
      }
    </method>
    <method name="CreateDelegate" static="true" arguments="t,o,m">
      var r = new Delegate();
      r.push({ to: o, m: m });
      return r;
    </method>
    <method name="DynamicInvoke">
      for(var j = 0; j &lt; this.length; ++j) {
        var h = this[j];
        if(!!h) h.m.apply(h.to, arguments);
      }
    </method>
  </class>
  <class name="System.EventArgs">
    <method name=".ctor" signature="" />
  </class>
  <class name="System.EventHandler" />
  <class name="System.Boolean" />
  <class name="System.Action" />
</classes>